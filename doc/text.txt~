IMPORTING THE MODULES:
 1. import pygame, random, sys
 2. from pygame.locals import *
 #Игра Dodger импортирует те же модули, что и предыдущие программы Pygame: pygame, random, sys и pygame.locals.
 Модуль pygame.locals содержит несколько постоянных переменных, которые использует Pygame, например, типы событий (QUIT, KEYDOWN и т. д.)
 и клавиши клавиатуры (K_ESCAPE, K_LEFT и т. д.). Используя синтаксис from pygame.locals import *,
 вы можете просто ввести QUIT в исходном коде вместо pygame.locals.QUIT.##
НАСТРОЙКА ПОСТОЯННЫХ ПЕРЕМЕННЫХ
4. WINDOWWIDTH = 600
5. WINDOWHEIGHT = 600
6. TEXTCOLOR = (255, 255, 255)
7. BACKGROUNDCOLOR = (0, 0, 0)
#Постоянные переменные в строках с 4 по 14 гораздо более информативны, чем ввод значений.
Например, из строки windowSurface.fill(BACKGROUNDCOLOR) понятнее, чем из windowSurface.fill((0, 0, 0)).
Вы можете легко изменить игру, изменив постоянные переменные. Изменяя WINDOWWIDTH в строке 4, вы автоматически меняете код везде,
где используется WINDOWWIDTH. Если бы вместо этого вы использовали значение 600, вам пришлось бы изменять каждое вхождение 600 в коде.
Легче изменить значение в константе один раз.#
8. FPS = 40
#Вызов метода mainClock.tick() в строке 189 замедлит игру достаточно, чтобы в нее можно было играть.
Вы передаете целое число в mainClock.tick(), чтобы функция знала, как долго нужно приостанавливать программу.
Это целое число (которое вы храните в FPS) представляет собой количество кадров в секунду, которое вы хотите, чтобы игра запускалась.
«Кадр» — это отрисовка графики на экране для одной итерации игрового цикла. Вы можете установить FPS на 40 и всегда вызывать mainClock.tick(FPS).
Затем вы можете изменить FPS на более высокое значение, чтобы игра работала быстрее, или на более низкое значение, чтобы замедлить игру.#
9. BADDIEMINSIZE = 10
10. BADDIEMAXSIZE = 40
11. BADDIEMINSPEED = 1
12. BADDIEMAXSPEED = 8
13. ADDNEWBADDIERATE = 6
#Строки с 9 по 13 задают еще несколько постоянных переменных, которые будут описывать падающих злодеев.
Ширина и высота злодеев будут между BADDIEMINSIZE и BADDIEMAXSIZE. Скорость, с которой злодеи падают с экрана,
будет находиться в пределах от BADDIEMINSPEED до BADDIEMAXSPEED пикселей за итерацию игрового цикла.
И новый злодей будет добавляться в верхнюю часть окна через каждую итерацию ADDNEWBADDIERATE в игровом цикле.#
14. PLAYERMOVERATE = 5
#PLAYERMOVERATE будет хранить количество пикселей, на которое персонаж игрока перемещается
в окне на каждой итерации игрового цикла, если персонаж движется. Увеличивая это число,
вы можете увеличить скорость передвижения персонажа.#
DEFINING FUNCTIONS:
#Есть несколько функций, которые вы создадите для игры:#
16. def terminate():
17. 	pygame.quit()
18. 	sys.exit()
#Pygame требует, чтобы вы вызывали как pygame.quit(), так и sys.exit().
Поместите их обоих в функцию с именем terminate().
Теперь вам нужно только вызвать метод terminate() вместо обеих функций pygame.quit() и sys.exit().#
20. def waitForPlayerToPressKey():
21.     while True:
22.         for event in pygame.event.get():
#Иногда вам может понадобиться приостановить игру, пока игрок не нажмет клавишу.
Создайте новую функцию с именем waitForPlayerToPressKey().
Внутри этой функции есть бесконечный цикл, который прерывается только при получении события KEYDOWN или QUIT.
В начале цикла pygame.event.get() возвращает список объектов Event для проверки.#
23.             if event.type == QUIT:
24.                 terminate()
#Если игрок закрыл окно, пока программа ожидает, пока игрок нажмет клавишу,
Pygame сгенерирует событие QUIT. В этом случае вызовите функцию terminate() в строке 24.#
25.             if event.type == KEYDOWN:
26.                 if event.key == K_ESCAPE: # pressing escape quits
27.                     terminate()
28.                 return
#Если событие QUIT или KEYDOWN не генерируется, код продолжает зацикливаться. 
Поскольку цикл ничего не делает, это создаст впечатление, что игра зависла, пока игрок не нажмет клавишу.#
30. def playerHasHitBaddie(playerRect, baddies):
31.     for b in baddies:
32.         if playerRect.colliderect(b['rect']):
33.             return True
34.     return False
#Функция playerHasHitBaddie() вернет True, если персонаж игрока столкнулся с одним из злодеев. 
Параметр baddies представляет собой список структур данных словаря «плохих».
 У каждого из этих словарей есть ключ 'rect', и значением этого ключа является объект Rect, представляющий размер и местоположение злоумышленника.

playerRect также является объектом Rect. Объекты Rect имеют метод с именем colliderect(), который возвращает True,
 если объект Rect столкнулся с переданным ему объектом Rect. В противном случае colliderect() вернет False.

Цикл for в строке 31 выполняет итерацию по каждому словарю злодеев в списке злодеев. 
Если какой-либо из этих злодеев сталкивается с персонажем игрока, то playerHasHitBaddie() вернет значение True. 
Если коду удастся перебрать всех злодеев в списке злодеев, не обнаружив коллизии ни с одним из них, он вернет False.#
36. def drawText(text, font, surface, x, y):
37.     textobj = font.render(text, 1, TEXTCOLOR)
38.     textrect = textobj.get_rect()
39.     textrect.topleft = (x, y)
40.     surface.blit(textobj, textrect)
#Рисование текста в окне включает в себя несколько шагов. Во-первых, вызов метода render() в строке 37 создает объект Surface,
 на котором отображается текст с использованием определенного шрифта.

Далее вам нужно знать размер и расположение объекта Surface. 
Вы можете получить объект Rect с этой информацией из метода поверхности get_rect().

Объект Rect, возвращаемый в строке 38 функцией get_rect(), имеет копию информации о ширине и высоте из объекта Surface.
 Строка 39 изменяет местоположение объекта Rect, устанавливая новое значение кортежа для его атрибута topleft.

Наконец, в строке 40 объект Surface визуализированного текста переносится на объект Surface, который был передан функции drawText().
 Отображение текста в Pygame требует на несколько шагов больше, чем простой вызов функции print(). 
Но если вы поместите этот код в одну функцию с именем drawText(), вам нужно будет вызвать эту функцию только для отображения текста на экране.
---------------------------------------------------------------------------------------------------------------------------------------------------
ИНИЦИАЛИЗАЦИЯ PYGAME И НАСТРОЙКА ОКНА
---------------------------------------------------------------------------------------------------------------------------------------------------
#Теперь, когда постоянные переменные и функции закончены, начните вызывать функции Pygame, которые настраивают окно и часы.#
42. # set up pygame, the window, and the mouse cursor
43. pygame.init()
44. mainClock = pygame.time.Clock()
#Строка 43 настраивает Pygame, вызывая функцию pygame.init(). Строка 44 создает объект pygame.time.Clock() и сохраняет его в переменной mainClock.
 Этот объект поможет нам предотвратить слишком быструю работу программы.#
45. windowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT))
#Строка 45 создает новый объект Surface, который используется для окна, отображаемого на экране. 
Вы можете указать ширину и высоту этого объекта Surface (и окна), передав кортеж с постоянными переменными WINDOWWIDTH и WINDOWHEIGHT. 
Обратите внимание, что в pygame.display.set_mode() передается только один аргумент: кортеж.
Аргументы для pygame.display.set_mode() — это не два целых числа, а один кортеж из двух целых чисел.#
46. pygame.display.set_caption('Dodger')
#Строка 46 устанавливает заголовок окна на строку «Dodger». Этот заголовок появится в строке заголовка в верхней части окна.#
47. pygame.mouse.set_visible(False)
#В Dodger курсор мыши не должен быть виден. Это потому, что вы хотите, чтобы мышь могла перемещать персонажа игрока по экрану, 
но курсор мыши мешал изображению персонажа на экране. Вызов pygame.mouse.set_visible(False) скажет Pygame сделать курсор невидимым.#
----------------------------------------------------------------------------------------------------------------------------------------------------
ПОЛНОЭКРАННЫЙ РЕЖИМ
----------------------------------------------------------------------------------------------------------------------------------------------------
#Функция pygame.display.set_mode() имеет второй необязательный параметр. Вы можете передать константу pygame.FULLSCREEN, 
чтобы окно занимало весь экран, а не было в окне. Посмотрите на эту модификацию строки 45:#
45. windowSurface = pygame.display.set_mode((WINDOWWIDTH, WINDOWHEIGHT), pygame.FULLSCREEN)
#Он по-прежнему будет WINDOWWIDTH и WINDOWHEIGHT по ширине и высоте окна, но изображение будет растянуто по размеру экрана.
Попробуйте запустить программу в полноэкранном режиме и без него.#
49. # set up fonts
50. font = pygame.font.SysFont(None, 48)
#Строка 49 создает объект Font для использования, вызывая pygame.font.SysFont().
 При передаче None используется шрифт по умолчанию. Передача 48 делает шрифт размером 48 пунктов.#
52. # set up sounds
53. gameOverSound = pygame.mixer.Sound('gameover.wav')
54. pygame.mixer.music.load('background.mid')
#Затем создайте объекты Sound и настройте фоновую музыку. Фоновая музыка будет постоянно играть во время игры,
 но звуковые объекты будут воспроизводиться только тогда, когда игрок проигрывает игру.

Вы можете использовать любой файл .wav или .mid для этой игры. Некоторые звуковые файлы доступны на веб-сайте этой книги по адресу http://invpy.com/downloads.
 Или вы можете использовать свои собственные звуковые файлы для этой игры, если они имеют имена файлов gameover.wav и background.mid. 
(Вы можете изменить строки, используемые в строках 53 и 54, чтобы они соответствовали именам файлов.)

Функция-конструктор pygame.mixer.Sound() создает новый объект Sound и сохраняет ссылку на этот объект в переменной gameOverSound.
 В своих собственных играх вы можете создавать сколько угодно звуковых объектов, каждый из которых имеет свой звуковой файл.

Функция pygame.mixer.music.load() загружает звуковой файл для воспроизведения фоновой музыки. 
Эта функция не возвращает никаких объектов, и одновременно может быть загружен только один файл фонового звука.#
56. # set up images
57. playerImage = pygame.image.load('player.png')
58. playerRect = playerImage.get_rect()
59. baddieImage = pygame.image.load('baddie.png')
#Затем вы загрузите файлы изображений, которые будут использоваться для персонажа игрока и злодеев на экране.
 Изображение персонажа хранится в файле player.png, а изображение злодеев хранится в файле baddie.png. 
Все злодеи выглядят одинаково, поэтому вам нужен только один файл изображения для них. 
Вы можете загрузить эти изображения с веб-сайта этой книги по адресу http://invpy.com/downloads.#
------------------------------------------------------------------------------------------------------------------------------------------------------------------
ОТОБРАЖЕНИЕ НАЧАЛЬНОГО ЭКРАНА
------------------------------------------------------------------------------------------------------------------------------------------------------------------
#При первом запуске игры отобразите на экране имя «Доджер». Вы также хотите указать игроку, что он может начать игру, нажав любую клавишу. 
Этот экран появляется для того, чтобы игрок успел подготовиться к началу игры после запуска программы.#
61. # show the "Start" screen
62. drawText('Dodger', font, windowSurface, (WINDOWWIDTH / 3), (WINDOWHEIGHT / 3))
63. drawText('Press a key to start.', font, windowSurface, (WINDOWWIDTH / 3) - 30, (WINDOWHEIGHT / 3) + 50)
64. pygame.display.update()
65. waitForPlayerToPressKey()
#В строках 62 и 63 вызовите функцию drawText() и передайте ей пять аргументов:
	1) Строка текста, который вы хотите отобразить.
	2) Шрифт, которым вы хотите отображать строку.
	3) Объект Surface, на который нужно отобразить текст.
	4) Координата X объекта Surface для рисования текста.
	5) Координата Y объекта Surface для рисования текста.
Может показаться, что для вызова функции нужно передать много аргументов, но имейте в виду, 
что этот вызов функции заменяет пять строк кода каждый раз, когда вы его вызываете. 
Это укорачивает программу и упрощает поиск ошибок, поскольку нужно проверять меньше кода.
Функция waitForPlayerToPressKey() будет приостанавливать игру в цикле до тех пор,
 пока не будет сгенерировано событие KEYDOWN. Затем выполнение выходит из цикла, и программа продолжает работать.#
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
НАЧАЛО ОСНОВНОГО ИГРОВОГО КОДА
---------------------------------------------------------------------------------------------------------------------------------------------------------------------
68. topScore = 0
69. while True:
#Значение переменной topScore начинается с 0 при первом запуске программы. Всякий раз, когда игрок проигрывает и имеет счет больше,
 чем текущий максимальный счет, лучший результат заменяется этим большим счетом.
Бесконечный цикл, начатый в строке 69, технически не является «игровым циклом». 
Игровой цикл обрабатывает события и отрисовывает окно во время работы игры.
 Вместо этого этот цикл while будет повторяться каждый раз, когда игрок начинает новую игру. 
Когда игрок проигрывает и игра перезагружается, выполнение программы возвращается к строке 69.#
70.     # set up the start of the game
71.     baddies = []
72.     score = 0
#· 'rect' — объект Rect, описывающий, где и какого размера находится злодей.
· 'скорость' - Как быстро злодей падает вниз экрана. Это целое число представляет пиксели за итерацию игрового цикла.
· 'surface' - объект Surface, на котором нарисовано масштабированное изображение злодея. Это объект Surface, который преобразуется в объект Surface, возвращаемый функцией pygame.display.set_mode().
Строка 72 сбрасывает счет игрока до 0.#
73.     playerRect.topleft = (WINDOWWIDTH / 2, WINDOWHEIGHT - 50)
#Начальное местоположение игрока находится в центре экрана и на 50 пикселей вверх от низа. 
Первый элемент в кортеже строки 73 — это X-координата левого края. Второй элемент кортежа — координата Y верхнего края.#
74.     moveLeft = moveRight = moveUp = moveDown = False
75.     reverseCheat = slowCheat = False
76.     baddieAddCounter = 0
#Переменные движения moveLeft, moveRight, moveUp и moveDown имеют значение False. Переменные reverseCheat и slowCheat также имеют значение False. 
Они будут установлены в True только тогда, когда игрок активирует эти читы, удерживая клавиши «z» и «x» соответственно.
Переменная baddieAddCounter — это счетчик, сообщающий программе, когда следует добавить нового злодея вверху экрана. 
Значение в baddieAddCounter увеличивается на единицу при каждом повторении игрового цикла.
Когда значение baddieAddCounter равно ADDNEWBADDIERATE, счетчик baddieAddCounter сбрасывается до 0,
 и в верхнюю часть экрана добавляется новый злодей. (Эта проверка выполняется позже в строке 130.)#
77.     pygame.mixer.music.play(-1, 0.0)
#Фоновая музыка начинает воспроизводиться в строке 77 вызовом pygame.mixer.music.play(). 
Первый аргумент — это количество раз, когда музыка должна повторяться. -1 — это специальное значение, 
указывающее Pygame, что вы хотите, чтобы музыка повторялась бесконечно.
Второй аргумент — это число с плавающей запятой, которое указывает, через сколько секунд музыка должна начать играть.
Прохождение 0.0 означает, что музыка начинает воспроизводиться с самого начала.#
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
ИГРОВОЙ ЦИКЛ
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Код игрового цикла постоянно обновляет состояние игрового мира, меняя положение игрока и злодеев, обрабатывая события, 
генерируемые Pygame, и рисуя игровой мир на экране. Все это происходит несколько десятков раз в секунду, 
что позволяет работать в «реальном времени».#
79.     while True: # the game loop runs while the game part is playing
80.         score += 1 # increase score
#Строка 79 — это начало основного игрового цикла. Строка 80 увеличивает счет игрока на каждой итерации игрового цикла.
Чем дольше игрок может идти без проигрыша, тем выше его счет. Цикл завершится только тогда, 
когда игрок либо проиграет игру, либо выйдет из программы.#
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ОБРАБОТКА СОБЫТИЙ
------------------------------------------------------------------------------------------------------------------------------------------------------------------------
#Существует четыре различных типа событий, которые программа будет обрабатывать: QUIT, KEYDOWN, KEYUP и MOUSEMOTION.#
82.         for event in pygame.event.get():
83.             if event.type == QUIT:
84.                 terminate()
#Строка 82 — это начало кода обработки событий. Он вызывает pygame.event.get(), который возвращает список объектов Event. 
Каждый объект Event представляет собой событие, произошедшее с момента последнего вызова pygame.event.get(). 
Код проверит атрибут типа объекта события, чтобы узнать, к какому типу относится событие, и соответствующим образом обработает событие.
Если атрибут type объекта Event равен QUIT, то пользователь закрыл программу. Постоянная переменная QUIT была импортирована из модуля pygame.locals.#
86.             if event.type == KEYDOWN:
87.                 if event.key == ord('z'):
88.                     reverseCheat = True
89.                 if event.key == ord('x'):
90.                     slowCheat = True
#Если тип события KEYDOWN, игрок нажал клавишу. Объект Event для событий клавиатуры также будет иметь ключевой атрибут,
который устанавливается равным целочисленному порядковому значению нажатой клавиши. 
Функция ord() вернет порядковый номер переданной ей буквы.
Например, строка 87 проверяет, описывает ли событие нажатие клавиши «z» с помощью event.key == ord('z'). 
Если это условие истинно, установите для переменной reverseCheat значение True, чтобы указать, что обратный чит был активирован. 
Строка 89 проверяет, была ли нажата клавиша «x», чтобы активировать медленный чит.
События клавиатуры Pygame всегда используют порядковые значения строчных букв, а не прописных. 
Всегда используйте event.key == ord('z') вместо event.key == ord('Z'). 
В противном случае ваша программа может действовать так, как если бы клавиша не была нажата.#
91.                 if event.key == K_LEFT or event.key == ord('a'):
92.                     moveRight = False
93.                     moveLeft = True
94.                 if event.key == K_RIGHT or event.key == ord('d'):
95.                     moveLeft = False
96.                     moveRight = True
97.                 if event.key == K_UP or event.key == ord('w'):
98.                     moveDown = False
99.                     moveUp = True
100.                 if event.key == K_DOWN or event.key == ord('s'):
101.                     moveUp = False
102.                     moveDown = True
#Строки с 91 по 102 проверяют, было ли событие сгенерировано нажатием одной из клавиш со стрелкой или WASD.
Не существует порядкового значения для каждой клавиши на клавиатуре, такой как клавиши со стрелками или клавиша esc.
Вместо этого модуль pygame.locals предоставляет постоянные переменные для использования.
Строка 91 проверяет, нажал ли игрок клавишу со стрелкой влево с помощью event.key == K_LEFT. 
Обратите внимание, что нажатие одной из клавиш со стрелками не только устанавливает для переменной движения значение True, 
но также устанавливает для переменной движения в противоположном направлении значение False.
Например, если нажат клавиша со стрелкой влево, то код в строке 93 устанавливает для moveLeft значение True, 
но также устанавливает для moveRight значение False. Это не позволяет игроку запутать программу, заставив ее думать,
что персонаж игрока должен двигаться в двух противоположных направлениях одновременно.
В Табл. 20-1 перечислены часто используемые постоянные переменные для атрибута ключа объектов Event, связанных с клавиатурой.#
104.             if event.type == KEYUP:
105.                 if event.key == ord('z'):
106.                     reverseCheat = False
107.                     score = 0
108.                 if event.key == ord('x'):
109.                     slowCheat = False
110.                     score = 0
#Событие KEYUP создается всякий раз, когда игрок перестает нажимать клавишу клавиатуры и отпускает ее.
Объекты событий с типом KEYUP также имеют ключевой атрибут, как и события KEYDOWN.
Строка 105 проверяет, отпустил ли игрок клавишу «z», которая деактивирует обратный чит. 
В этом случае строка 106 устанавливает для reverseCheat значение False, а строка 107 сбрасывает счет до 0.
Сброс счета должен отбить у игрока желание использовать читы.
Строки со 108 по 110 делают то же самое для клавиши «x» и медленного чита. Когда клавиша «x» отпущена, 
для slowCheat устанавливается значение False, а счет игрока сбрасывается до 0.#
111.                 if event.key == K_ESCAPE:
112.                         terminate()
#В любой момент во время игры игрок может нажать клавишу esc на клавиатуре, чтобы выйти. 
Строка 14 проверяет, была ли выпущенная клавиша клавишей esc, проверяя event.key == K_ESCAPE. 
Если да, то в строке 112 вызывается функция terminate() для выхода из программы.#
114.                 if event.key == K_LEFT or event.key == ord('a'):
115.                     moveLeft = False
116.                 if event.key == K_RIGHT or event.key == ord('d'):
117.                     moveRight = False
118.                 if event.key == K_UP or event.key == ord('w'):
119.                     moveUp = False
120.                 if event.key == K_DOWN or event.key == ord('s'):
121.                     moveDown = False
#Строки со 114 по 121 проверяют, перестал ли игрок удерживать нажатой одну из клавиш со стрелками или WASD.
В этом случае код устанавливает для соответствующей переменной движения значение False.
Например, если бы игрок удерживал нажатой клавишу со стрелкой влево, то для параметра moveLeft в строке 93 было бы установлено значение True. 
Когда он отпустит его, условие в строке 114 будет оцениваться как True, а для переменной moveLeft будет установлено значение True. ЛОЖЬ.#
----------------------------------------------------------------------------------------------------------------------------------------------
МЕТОД MOVE_IP()
----------------------------------------------------------------------------------------------------------------------------------------------
123.             if event.type == MOUSEMOTION:
124.                 # If the mouse moves, move the player where the cursor is.
125.                 playerRect.move_ip(event.pos[0] - playerRect.centerx, event.pos[1] - playerRect.centery)
#Теперь, когда вы обработали события клавиатуры, давайте обработаем любые события мыши, которые могли быть сгенерированы.
Игра Dodger ничего не делает, если игрок нажал кнопку мыши, но реагирует, когда игрок перемещает мышь.
Это дает игроку два способа управления персонажем в игре: клавиатуру или мышь.

Событие MOUSEMOTION генерируется при каждом перемещении мыши. Объекты событий с типом MOUSEMOTION также имеют атрибут
с именем pos для положения события мыши. Атрибут pos хранит кортеж X- и Y-координат, где курсор мыши перемещался в окне.
Если тип события — MOUSEMOTION, персонаж игрока перемещается в позицию курсора мыши.

Метод move_ip() для объектов Rect перемещает местоположение объекта Rect по горизонтали или вертикали на определенное количество пикселей.
Например, playerRect.move_ip(10, 20) переместит объект Rect на 10 пикселей вправо и на 20 пикселей вниз.
Чтобы переместить объект Rect влево или вверх, передайте отрицательные значения.
Например, playerRect.move_ip(-5, -15) переместит объект Rect влево на 5 пикселей и вверх на 15 пикселей.

«IP» в конце move_ip() означает «на месте». Это связано с тем, что метод изменяет сам объект Rect,
а не возвращает новый объект Rect с изменениями. Существует также метод move(), который не изменяет объект Rect,
а вместо этого создает и возвращает новый объект Rect в новом месте.#
-------------------------------------------------------------------------------------------------------------------------------------------------
ДОБАВЛЕНИЕ НОВЫХ ЗЛОДЕЕВ
--------------------------------------------------------------------------------------------------------------------------------------------------
127.         # Add new baddies at the top of the screen, if needed.
128.         if not reverseCheat and not slowCheat:
129.             baddieAddCounter += 1
#На каждой итерации игрового цикла увеличивайте переменную baddieAddCounter на единицу.
Это происходит только в том случае, если читы не включены. Помните, что для reverseCheat и slowCheat установлено значение True,
пока удерживаются клавиши «z» и «x» соответственно.#

#И пока эти клавиши удерживаются, значение baddieAddCounter не увеличивается. Поэтому в верхней части экрана не появятся новые злодеи.#
130.         if baddieAddCounter == ADDNEWBADDIERATE:
131.             baddieAddCounter = 0
132.             baddieSize = random.randint(BADDIEMINSIZE, BADDIEMAXSIZE)
133.             newBaddie = {'rect': pygame.Rect(random.randint(0, WINDOWWIDTH-baddieSize), 0 - baddieSize, baddieSize, baddieSize),
134.                         'speed': random.randint(BADDIEMINSPEED, BADDIEMAXSPEED),
135.                         'surface':pygame.transform.scale(baddieImage, (baddieSize, baddieSize)),
136.                         }
#Когда baddieAddCounter достигает значения в ADDNEWBADDIERATE, пора добавить нового злодея в верхнюю часть экрана.
Во-первых, счетчик baddieAddCounter сбрасывается обратно на 0.

Строка 132 генерирует размер злодея в пикселях. Размер будет представлять собой случайное целое число между BADDIEMINSIZE и BADDIEMAXSIZE,
которые представляют собой константы, установленные на 10 и 40 в строках 9 и 10.

В строке 133 создается новая структура данных злодея. Помните, что структура данных для злодеев — это просто словарь с ключами «прямая»,
«скорость» и «поверхность». Ключ 'rect' содержит ссылку на объект Rect, в котором хранится местоположение и размер злодея.
Вызов функции-конструктора pygame.Rect() имеет четыре параметра: координата X верхнего края области, координата Y левого края области,
ширина в пикселях и высота в пикселях.

Злодей должен появляться случайным образом в верхней части окна, поэтому передайте random.randint(0, WINDOWWIDTH-baddieSize)
для X-координаты левого края. Причина, по которой вы передаете WINDOWWIDTH-baddieSize вместо WINDOWWIDTH, заключается в том,
что это значение относится к левому краю бэдди. Если левый край злодея находится слишком далеко от правой стороны экрана,
то часть злодея будет за краем окна и не будет видна.

Нижний край злодея должен быть чуть выше верхнего края окна. Y-координата верхнего края окна равна 0.
Чтобы поместить туда нижний край злодея, установите верхний край равным 0 - baddieSize.

Ширина и высота злодея должны быть одинаковыми (изображение квадратное),
поэтому передайте baddieSize в качестве третьего и четвертого аргументов.

Скорость, с которой злодей перемещается по экрану, задается клавишей «скорость».
Задайте случайное целое число от BADDIEMINSPEED до BADDIEMAXSPEED.#

138.             baddies.append(newBaddie)
#Строка 138 добавит только что созданную структуру данных злоумышленника в список структур данных злоумышленника.
Программа будет использовать этот список, чтобы проверить, не столкнулся ли игрок с кем-либо из злодеев, и узнать, где на окне рисовать злодеев#
----------------------------------------------------------------------------------------------------------------------------------------------------
ПЕРЕМЕЩЕНИЕ ПЕРСОНАЖА ИГРОКА
----------------------------------------------------------------------------------------------------------------------------------------------------
140.         # Move the player around.
141.         if moveLeft and playerRect.left > 0:
142.             playerRect.move_ip(-1 * PLAYERMOVERATE, 0)
#Четырем переменным движения moveLeft, moveRight, moveUp и moveDown присваиваются значения True и False,
когда Pygame генерирует события KEYDOWN и KEYUP соответственно.

Если персонаж игрока движется влево и левый край персонажа игрока больше 0 (что является левым краем окна),
то playerRect следует переместить влево.

Вы всегда будете перемещать объект playerRect на количество пикселей в PLAYERMOVERATE.
Чтобы получить отрицательную форму целого числа, умножьте его на -1. В строке 142,
поскольку в PLAYERMOVERATE хранится 5, выражение -1 * PLAYERMOVERATE оценивается как -5.#


#Следовательно, вызов playerRect.move_ip(-1 * PLAYERMOVERATE, 0) изменит местоположение playerRect на 5 пикселей левее его текущего местоположения.#
143.         if moveRight and playerRect.right < WINDOWWIDTH:
144.             playerRect.move_ip(PLAYERMOVERATE, 0)
145.         if moveUp and playerRect.top > 0:
146.             playerRect.move_ip(0, -1 * PLAYERMOVERATE)
147.         if moveDown and playerRect.bottom < WINDOWHEIGHT:
148.             playerRect.move_ip(0, PLAYERMOVERATE)
#Строки со 143 по 148 делают то же самое для трех других направлений: вправо, вверх и вниз.
Каждый из трех операторов if в строках с 143 по 148 проверяет, установлено ли для их переменной move значение True
и находится ли край объекта Rect игрока внутри окна. Затем он вызывает move_ip() для перемещения объекта Rect.#
----------------------------------------------------------------------------------------------------------------------------------------------------------
ФУНЦИЯ pygame.mouse.set_pos()
----------------------------------------------------------------------------------------------------------------------------------------------------------
150.         # Move the mouse cursor to match the player.
151.         pygame.mouse.set_pos(playerRect.centerx, playerRect.centery)
#Строка 151 перемещает курсор мыши в ту же позицию, что и персонаж игрока. Функция pygame.mouse.set_pos() перемещает курсор мыши в координаты X и Y,
которые вы ей передаете. Это сделано для того, чтобы курсор мыши и персонаж игрока всегда находились в одном и том же месте.#


#В частности, курсор будет находиться прямо посередине объекта Rect персонажа, потому что вы передали атрибуты centerx и centery playerRect для координат.
Курсор мыши все еще существует, и его можно перемещать, даже если он невидим из-за вызова pygame.mouse.set_visible(False) в строке 47.#
153.         # Move the baddies down.
154.         for b in baddies:
#Теперь прокрутите каждую структуру данных злодея в списке злодеев, чтобы немного переместить их вниз.#
155.             if not reverseCheat and not slowCheat:
156.                 b['rect'].move_ip(0, b['speed'])
#Если ни один из читов не был активирован, то сместите местоположение злодея вниз на количество пикселей,
равное его скорости, которая хранится в ключе «скорость».#
------------------------------------------------------------------------------------------------------------------------------------------------------------
ВНЕДРЕНИЕ ЧИТ-КОДОВ
------------------------------------------------------------------------------------------------------------------------------------------------------------
157.             elif reverseCheat:
158.                 b['rect'].move_ip(0, -5)
#Если активирован обратный чит, то злодей должен переместиться вверх на пять пикселей.
Передача -5 для второго аргумента функции move_ip() приведет к перемещению объекта Rect вверх на пять пикселей.#
159.             elif slowCheat:
160.                 b['rect'].move_ip(0, 1)
#Если был активирован медленный чит, то злодей должен двигаться вниз, но только с медленной скоростью в один пиксель за итерацию игрового цикла.
Нормальная скорость злодея (которая хранится в ключе «скорость» структуры данных злодея) игнорируется, пока активируется медленный чит.#
-----------------------------------------------------------------------------------------------------------------------------------------------------------
УДАЛЕНИЕ ЗЛОДЕЕВ
-----------------------------------------------------------------------------------------------------------------------------------------------------------
162.         # Delete baddies that have fallen past the bottom.
163.         for b in baddies[:]:
#Любые злодеи, которые упали ниже нижнего края окна, должны быть удалены из списка злодеев.
Помните, что при переборе списка не изменяйте содержимое списка, добавляя или удаляя элементы.
Таким образом, вместо того, чтобы перебирать список злодеев с помощью цикла for, перебирайте копию списка злодеев.
Эта копия создается с помощью пустого оператора среза [:].#


#Цикл for в строке 163 использует переменную b для текущего элемента в итерации через baddies[:].#
164.             if b['rect'].top > WINDOWHEIGHT:
165.                 baddies.remove(b)

#Давайте оценим выражение b['rect'].top. b — текущая структура данных злодея из списка злодеев[:].
Каждая структура данных злоумышленника в списке представляет собой словарь с ключом 'rect', в котором хранится объект Rect.
Итак, b['rect'] — это объект Rect для злодея.

Наконец, атрибут top — это координата Y верхнего края прямоугольной области.
Помните, что координаты Y увеличиваются вниз. Таким образом, b['rect'].top > WINDOWHEIGHT проверит,
находится ли верхний край злодея ниже нижней части окна.

Если это условие истинно, то строка 165 удаляет структуру данных злодея из списка злодеев.#
-------------------------------------------------------------------------------------------------------------------------------------------------------------
РИСОВАНИЕ ОКНА
-------------------------------------------------------------------------------------------------------------------------------------------------------------
#После обновления всех структур данных игровой мир следует отрисовать с помощью функций изображения Pygame.
Поскольку игровой цикл выполняется несколько раз в секунду, рисование злодеев и игрока в новых позициях делает их движения плавными и естественными.#
167.         # Draw the game world on the window.
168.         windowSurface.fill(BACKGROUNDCOLOR)

Во-первых, прежде чем рисовать что-либо еще, строка 168 затемняет весь экран, чтобы стереть все, что на нем было нарисовано ранее.

Помните, что объект Surface в windowSurface — это специальный объект Surface, потому что он был возвращен функцией pygame.display.set_mode().
Следовательно, все, что нарисовано на этом объекте Surface, появится на экране после вызова pygame.display.update().
-----------------------------------------------------------------------------------------------------------------------------------------------------------
ПОДСЧЕТ ОЧКОВ ИГРОКА
-----------------------------------------------------------------------------------------------------------------------------------------------------------
170.         # Draw the score and top score.
171.         drawText('Score: %s' % (score), font, windowSurface, 10, 0)
172.         drawText('Top Score: %s' % (topScore), font, windowSurface, 10, 40)

#Строки 171 и 172 отображают текст для оценки и максимальной оценки в верхнем левом углу окна.
Выражение 'Score: %s' % (score) использует интерполяцию строк для вставки значения переменной score в строку.

Передайте эту строку, объект Font, хранящийся в переменной font, объект Surface, на котором нужно нарисовать текст, и координаты X и Y места,
где должен быть размещен текст. DrawText() будет обрабатывать вызовы методов render() и blit().

Для наибольшего результата сделайте то же самое. Передайте 40 для координаты Y вместо 0,
чтобы текст наивысшего балла отображался под текстом балла.#
------------------------------------------------------------------------------------------------------------------------------------------------------------
ОТРИСОВКА ПЕРСОНАЖА ИГРОКА
------------------------------------------------------------------------------------------------------------------------------------------------------------
174.         # Draw the player's rectangle
175.         windowSurface.blit(playerImage, playerRect)
#Информация об игроке хранится в двух разных переменных. playerImage — это объект Surface, содержащий все цветные пиксели,
из которых состоит изображение персонажа игрока. playerRect — это объект Rect, в котором хранится информация о размере и местоположении персонажа игрока.#

#Метод blit() рисует изображение персонажа игрока (в playerImage) на поверхности окна в месте, указанном в playerRect.#
177.         # Draw each baddie
178.         for b in baddies:
179.             windowSurface.blit(b['surface'], b['rect'])

#Цикл for в строке 178 рисует всех злодеев на объекте windowSurface. Каждый элемент в списке злодеев — это словарь.
Словарные ключи «surface» и «rect» содержат объект Surface с изображением злодея и объект Rect с информацией о положении и размере соответственно.#
181.         pygame.display.update()
#Теперь, когда все нарисовано в windowSurface, нарисуйте этот объект Surface на экране, вызвав pygame.display.update().#
-----------------------------------------------------------------------------------------------------------------------------------------------------------
ОБНАРУЖЕНИЕ ПРОБЛЕМ(СТОЛКНОВЕНИЙ)
-----------------------------------------------------------------------------------------------------------------------------------------------------------
183.         # Check if any of the baddies have hit the player.
184.         if playerHasHitBaddie(playerRect, baddies):
185.             if score > topScore:
186.                 topScore = score # set new top score
187.             break
#Строки 184 проверяют, столкнулся ли игрок с какими-либо злодеями, вызывая playerHasHitBaddie().
Эта функция вернет True, если персонаж игрока столкнулся с любым из злодеев в списке злодеев. В противном случае функция вернет False.#

#Если персонаж игрока ударил злодея, в строках 185 и 186 обновляется максимальный счет, если текущий счет больше его.
Затем выполнение выходит из игрового цикла на строке 187. Выполнение программы переместится на строку 191.#

189.         mainClock.tick(FPS)
#Чтобы компьютер не выполнял игровой цикл как можно быстрее (что было бы слишком быстро для игрока), вызовите mainClock.tick(),
чтобы сделать паузу на короткое время. Пауза будет достаточно длинной, чтобы обеспечить выполнение около 40
(значение, хранящееся внутри переменной FPS) итераций игрового цикла каждую секунду.#
-----------------------------------------------------------------------------------------------------------------------------------------------------------
ЭКРАН ЗАВЕРШЕНИЯ ИГРЫ
-----------------------------------------------------------------------------------------------------------------------------------------------------------
191.     # Stop the game and show the "Game Over" screen.
192.     pygame.mixer.music.stop()
193.     gameOverSound.play()
#Когда игрок проигрывает, игра перестает воспроизводить фоновую музыку и воспроизводится звуковой эффект «игра окончена».
Строка 192 вызывает функцию stop() в модуле pygame.mixer.music, чтобы остановить фоновую музыку.
Строка 193 вызывает метод play() для объекта Sound, хранящегося в gameOverSound.#


195.     drawText('GAME OVER', font, windowSurface, (WINDOWWIDTH / 3), (WINDOWHEIGHT / 3))
196.     drawText('Press a key to play again.', font, windowSurface, (WINDOWWIDTH / 3) - 80, (WINDOWHEIGHT / 3) + 50)
197.     pygame.display.update()
198.     waitForPlayerToPressKey()

#В строках 195 и 196 вызывается функция drawText() для рисования текста «game over» в объекте windowSurface.
Строка 197 вызывает pygame.display.update() для отрисовки этого объекта Surface на экране.
После отображения этого текста игра останавливается до тех пор, пока игрок не нажмет клавишу, вызвав функцию waitForPlayerToPressKey().#

200.     gameOverSound.stop()

#После того, как игрок нажмет клавишу, выполнение программы вернется из вызова waitForPlayerToPressKey() в строке 198.
В зависимости от того, как долго игрок будет нажимать клавишу, звуковой эффект «игра окончена» может продолжаться или не воспроизводиться.
Чтобы остановить этот звуковой эффект перед началом новой игры, в строке 200 вызывается функция gameOverSound.stop().#














































































































































































